# Ripple共识

近年来，对分布式同步系统的兴趣和研究显著增加，其中大多数研究集中在分布式支付网络。这样的网络允许不受集中源控制的快速、低成本的传输。尽管分布式支付网络的经济效益和弊端值得我们进行深入研究，但本文的主要工作集中在以下几个方面：所有分布式支付系统必须面对的技术挑战。虽然这些问题是多种多样的，但我们将它们分为三大类：正确性、一致性和实用性。正确性，意味着分布式支付系统必须能够区分正确事务和欺诈性事务之间的区别。在传统的基于信用的设置中，通过大型机构以及数字签名保证交易确实是从由交易所申明的大型机构发出的。然而，在分布式系统中，没有这样的基于信用的保证。并且在网络中交易发起方的身份，甚至都不知道。因此，对于分布式支付系统来说，必须有一种全新的可以保证正确性的替代方案。

一致性是指在分布式交易系统中如果维持一个唯一的值得信赖的账户以及交易数据。与正确性问题相似，区别在于恶意网络用户无法创建欺诈性交易，它可能能够创建多个正确的交易，而这些事务彼此之间并不知道对方的存在。这些正确的交易结合起来就制造了一个欺诈行为。例如，恶意用户可能同时进行两次购买，他们的帐户中只有足够的资金单独支付其中一次购买，但无法支付这两次购买。尽管每笔交易本身都是正确的，但如果这两笔交易同时执行，分布式交易网络作为一个系统并不知道这两次交易是同时进行的，这通常会出现一个被认为是“双重支付”的问题。因此，一致性问题可以概括为网络中只存在一组全网公认的事务的要求。

可用性是一个略显抽象的问题，我们通常将其定义为分布式支付系统的“有用性”，但在实践中，通常会被简化为系统的延迟。一个分布式系统是正确和一致的，但它如果需要一年的时间来处理一个交易，显然这是一个不可行的支付系统。可用性的其他方面包括参与正确性和一致性过程所需的计算能力水平，或最终用户为避免在网络中被欺骗而需要的技术熟练程度。

许多这些问题早在现代分布式计算机系统出现之前就已经被探讨过了，通过被称为“拜占庭将军问题”。在这个问题上，一群将军每个人都控制着一支军队的一部分，并且必须通过互相派遣信使来协调一次攻击。由于将军们身处陌生和敌对的领土，信使们可能无法到达他们的目标(就像分布式网络中的节点可能失败一样，或者发送损坏的数据而不是预期的消息)。问题的另一个方面是，一些将军可能是叛徒，无论是单独的，还是合谋在一起，这样的信息可能会到达，目的是创造一个使得整个进攻失败的错误的计划，分布式系统可能试图说服系统接受欺诈性交易，或同一真实事务的多个版本，从而导致双重支出)。因此，分布式支付系统必须在面对标准故障和所谓的“拜占庭”故障时都是健壮的，这种故障可能是由网络中的多个来源协作产生的。

在本文中，我们分析了一个分布式支付系统的具体实现：Ripple协议。我们重点研究了如果通过Ripple算法，实现上述所说的正确性、一致性、和可用性(在必要的和预定的容忍阈值内)。

##在我们开始描述Ripple网络之前，先介绍几个术语：##

1：Server，Server是运行Ripple Server软件的任何实体(与只允许用户发送和接收资金的Ripple客户端软件相反)，它参与一致性同步过程。

2：Ledger，Ledger是每个用户帐户中货币数量的记录，代表了网络的“基本真相”。随着一笔笔交易记录通过一致性同步过程，Ledger会被反复更新。

3：Last-Closed Ledger: Last-Closed Ledger是最新的总帐本，已得到一致性同步过程，因此代表了网络的当前状态。

4：Open Ledger：Open Ledger是一个节点的当前运营状态(每个节点保持自己的账本)。用户发起的交易发送给Server节点，然后有Server节点放入Open Ledger中，Open Ledger中交易直到通过了一致性同步过程，才会转化为最终的交易，这个时候Open Ledger就转化为了Last-Closed Ledger。

5：Unique Node List(UNL)：每个服务器都维护一个唯一的节点列表，这一组服务器会参与一致性同步过程。在一致性同步过程中，只有来自节点列表中的投票是有效的，这些投票将会被用于进行一致性同步。因此，UNL代表网络的一个子集，当集体采取该子集时，该子集将被认为是“受信任的”，不会通过密谋来欺诈分布式交易系统。请注意，此“信任”的定义不需要UNL的每个单独成员都受信任。

6：Proposer：任何服务器都可以广播要包含在协商一致过程中的交易，并且当新的协商一致回合开始时，每个服务器都试图包含每个有效的事务。然而在一致性同步期间，分布式交易系统只考虑来自UNL上的节点Server的建议。

##同步过程术语介绍##
我们使用术语“nonfaulty”来指的是网络中的那些诚实而没有错误的节点。相反，faulty节点是产生错误的节点，这些节点可能是诚实节点（由于数据损坏或者实现错误）或欺诈节点(拜占庭错误)。我们将验证交易的概念简化为一个简单的二进制决策问题：每个节点必须根据它的信息进行判断，然后给出了0或1的值。
我们根据以下三条公理界定共识：

1：C1：每个nonfaulty节点都在有限的时间内做出决策。
2：C2：每个nonfaulty节点都达成同样的决策
3：C3：所有的nonfaulty节点，都可以是0或者1。（在nonfaulty节点接收到交易信息中，其可根据情况做出0或者1的决策）
