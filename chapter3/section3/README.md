# Ripple共识

分布式支付网络允许不受中心机构控制的快速、低成本的价值传输。所有分布式支付系统必须面对的技术挑战可以分为三大类：正确性、一致性和实用性。

**正确性**是指分布式支付系统必须能够区分正确交易和欺诈交易。在传统的基于信用的机制中，通过大型机构以及数字签名保证交易确实是从由交易所申明的大型机构发出的。然而，在分布式支付系统中，没有这样的基于信用的保证，并且在网络中交易发起方的身份，甚至都不知道。因此，对于分布式支付系统来说，必须有一种全新的可以保证正确性的替代方案。

**一致性**是指分布式支付系统必须维持唯一的值得信赖的账户以及交易数据。与正确性问题相似，区别在于恶意用户无法创建欺诈交易，但是它能够创建多个正确的交易，而这些交易彼此之间并不知道对方的存在。这些正确的交易结合起来就可以进行欺诈行为。例如，恶意用户可能同时进行两次购买，但他们的帐户中只有足够的资金单独支付其中的一次购买。尽管每笔交易本身都是正确的，但如果这两笔交易同时执行，分布式支付网络作为一个系统并不知道这两次交易是同时进行的，这通常会出现一个被认为是“双重支付”的问题。因此，一致性问题可以概括为网络中只存在一组全网公认的交易的要求。

**可用性**是一个略显抽象的问题，我们通常将其定义为分布式支付系统的“有用性”，但在实践中，通常会被简化为分布式支付系统的网络延迟。一个分布式系统是正确和一致的，但它如果需要一年的时间来处理一个交易，显然这是一个不可行的支付系统。可用性的其他方面包括参与正确性和一致性过程所需的计算能力水平，或最终用户为避免在网络中被欺骗而需要的技术熟练程度。

这些问题通常被称为“拜占庭将军问题”。一群将军每个人都控制着一支军队的一部分，并且必须通过互相派遣信使来协调一次攻击。由于将军们身处陌生和敌对的领土，信使们可能无法到达他们的目标(就像分布式网络中的节点可能失败一样，或者发送损坏的数据而不是预期的消息)。问题的另一个方面是，一些将军可能是叛徒，无论是单独的，还是密谋在一起的，这样的信息可能会到达，目的是创造一个使得整个进攻失败的错误的计划，这些叛徒可能试图说服分布式支付系统接受欺诈交易，或同一真实交易的多个版本，从而导致双重支出)。因此，分布式支付系统必须在面对标准故障和所谓的“拜占庭”故障时都是健壮的，这种故障可能是由网络中的多个节点密谋产生的。

在本文中，我们分析了一个分布式支付系统的具体实现：Ripple协议。

##在我们开始描述Ripple协议之前，先介绍几个术语：

1：Server，Server是运行Ripple Server软件的任何实体(与只允许用户发送和接收资金的Ripple客户端软件相反)，它参与共识。

2：Ledger，Ledger是用户账户的记录，代表了分布式支付网络的“真是面孔”。随着一笔笔交易通过共识，Ledger会被反复更新。

3：Last-Closed Ledger: Last-Closed Ledger是最新的总帐本，已完成共识，因此代表了网络的当前状态。

4：Open Ledger：Open Ledger是一个节点的当前状态(每个节点维护自己的账本)。用户发起的交易发送给Server节点，然后由Server节点放入自身的Open Ledger中，Open Ledger中的交易直到通过了共识，才会转化为最终的交易，这个时候Open Ledger就转化为了Last-Closed Ledger。

5：Unique Node List(UNL)：每个Server节点都维护一个唯一的节点列表，这一组Server节点会参与共识。在共识过程中，只有来自节点列表中的投票是有效的，这些投票将会被用于进行交易共识。因此，UNL代表网络的一个子集，当分布式支付系统采取该子集时，该子集将被认为是“受信任的”，不会通过密谋来欺诈分布式交易系统。请注意，此“信任”的定义不需要UNL中的每个单独成员都受信任。

6：Proposer：任何Server节点都可以广播要包含在共识过程中的交易，并且当新的共识回合开始时，每个Server节点都试图包含每个有效的事务。然而在同步期间，分布式支付系统只考虑来自UNL上的Server节点的投票。

##同步术语
我们使用“nonfaulty”来表示网络中的那些**诚实而没有错误**的节点。相反，faulty节点是产生错误的节点，这些节点可能是诚实节点（由于数据损坏或者实现错误）或欺诈节点(拜占庭错误)。我们将验证交易的概念简化为一个简单的二进制决策问题：每个节点必须根据它所接受到的信息对交易进行判断，然后给出了0或1的值。
我们根据以下三条公理定义达成共识：

C1：每个nonfaulty节点都在有限的时间内做出决策。

C2：每个nonfaulty节点都达成同样的决策。

C3：每个nonfaulty节点，可以对交易自由地进行投票（0或者1）

##同步目标
我们在这项工作中的目的是表明，Ripple协议使用的一致性算法将在每个Last-Closed Ledger中达成共识(即便由于Last-Close Ledger中的每个交易都是无效的，从而导致Last-Close Ledger是没有价值的)，由于网络中的每个Server节点只对来自受信任的一组节点(UNL中的其他节点)的建议进行投票，而且由于每个节点可能有不同的UNL，所以我们还表明无论UNL中的节点身份如何，全网都只会达成一个唯一的一致性结果。这一目标也被称为防止网络中的“分叉”：在这种情况下，两个不相交的节点集各自达成独立的一致性状态。每个节点集中的节点可以观察到两个不同的Last-Closed Ledger。

最后，我们将展示在(n−1)/5失败的情况下，Ripple协议可以实现这些目标。Ripple协议还可以做得更多，并且我们还将展示Ripple协议的几个非常棒的特性，这些特性可以帮助我们极大地加强分布式交易系统的可用性。

##Ripple共识算法
为了保持网络的正确性和一致性，所有节点每隔几秒钟应用一次Ripple协议一致性算法(RPCA)。一旦达成共识，当前的Ledger被认为是“Closed”，并成为Last-closed Ledger。如果一致性算法是成功的，而且网络中没有分叉，那么由网络中德所有节点共同维护的Last-Closed Ledger将会是相同的。

RPCA是分回合的：