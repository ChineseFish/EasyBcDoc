# 可用性

虽然可用性的许多成分是主观的，但是收敛确实是可以进行证明的：共识过程将在有限的时间内终止。

##收敛
我们把收敛定义为一个时间点，在这个时间点上面，RPCA在总帐上面达成了强正确性共识，随后Open Ledger会转化为Last-Closed Ledger。注意，虽然技术层面的弱正确性仍然代表着RPCA的收敛，但是这仅是一个无效的收敛，因为上诉的C3命题被违反了，任何交易都不会被确认。从上面的结果中，我们可以知道在不大于{% math %}(n−1)/5{% endmath %}数量拜占庭式faulty节点的情况下，分布式支付系统的强正确性总是可以实现的，而且只要分布式支付网络满足UNL连通性条件（公式3），那么在整个过程中分布式支付网络就只能达成一个唯一的共识。剩下的就是表明，当强正确性和UNL的连通性都得到满足时，分布式支付系统就会在有限的时间内达成共识。

因为共识算法本身是确定的，并且在共识被终止之前有一个预设的回合数{% math %}t{% endmath %}，而且当前的一组消息需要被声明为已批准或不批准(即使此时没有任何一笔交易超过共识算法所需的80%阀值，这只是一次无价值的共识过程)，所以共识算法终止的限制因素是Server节点之间的通信延时。为了弹性化通信延时，Server节点的响应时间会被监控，延迟大于预设值{% math %}b{% endmath %}的节点会被从所有UNL中删除。尽管这样做保证了共识过程会在时间{% math %}tb{% endmath %}内结束，但是必须指出，在所有网络延时大于预设值的Server节点被丢弃之后，最终的UNL以及UNLs必须满足达成上述正确性和一致性的界限。如果所有节点的初始UNL配置都保持不变，但由于延迟而将一些节点从网络中删除，则正确性和一致性保证不会自动维持。正确性和一致性必须由新的UNL集合进行维持。

##启发式方法和过程
如上所述，在Ripple网络中的所有Server节点都采用了启发式延迟限制，用来保证共识算法的收敛。此外，下列启发式方法和过程为RPCA提供了更高的可用性。

1：在每一轮（总共有t轮）共识过程中，所有Server节点都必须有一个强制性的2秒时间来发布它们的初始”candidate set“。虽然这为每一轮共识引入了2秒的下限，但可以保证所有具有合理延迟的节点都有能力参与共识过程。

2：在每一轮共识过程中，将投票情况记录下来，然后把那些进行一些常见的、易于识别的恶意行为的节点进行标记并从UNL中删除（其中包括那些在每个交易上的投票“否”，以及那些持续提议那些无法通过共识的节点）

3：向所有用户提供了一个{% math %}p_c{% endmath %}值最低的默认UNL。虽然用户可以也应该自己选择UNL，但是这个默认的UNL保证即使是毫无经验的用户也可以参与共识过程，并且以极高的概率实现正确性和一致性。

4：使用网络分割检测算法，去避免网络中的分叉。虽然共识算法保证了Last-Closed Ledger上的交易是正确的。但它无法消除在连接性较差的网络上的不同分区上存在多个Last-Closed Ledger的可能性。若要尝试并确定是否发生了这样的网络分割，每个节点都应当监控其UNL的活动成员的大小。如果该大小突然下降到预设阈值以下，则可能发生网络分割。由于UNL中的某一包含大量节点的分组可能由于各种原因而暂时网络延时陡升，为了避免这种情况被UNL的其他Server节点判断为高延时节点，而被从UNL中剔除，Server节点被允许发布一个“临时验证”，在“临时验证”阶段，UNL中的Server节点不会对交易进行投票，并且申明共识仍在进行中，而不是在一个已经失去连接的子网络中进行新的一轮的共识过程。

5：虽然可以仅在一轮共识中应用RPCA。但在共识阀值为80%第四轮共识之前，通过多轮（每一轮都会适量增加共识阀值）的共识，可以获取更高的可用性。少数的延时Server节点，会成为整个分布式支付系统的瓶颈，在这种情况下，通过多轮的共识可以检测潜在的高延时的节点。在较低阀值要求的回合中，这些延时节点可能能够跟上共识的速度，但是随着阀值的增加，那些跟不上共识速度的节点会被识别出来。就一轮共识而言，只有很少的一部分交易可以达到80%的Server节点的确认，从而使得即使是速度较慢的Server节点也可以跟上共识的速度，这会降低整个分布式支付系统性能。