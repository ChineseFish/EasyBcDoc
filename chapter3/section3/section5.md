<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>
# 可用性

虽然可用性的许多成分是主观的，但确实可以证明的是收敛：共识过程将在有限的时间内终止。

##收敛
我们把收敛定义为一个时间点，在这个时间点上面，RPCA在总帐上面达成了强正确性共识，随后这个总帐转化为Last-closed Ledger。注意，虽然技术上弱正确性仍然代表着算法的收敛性，但是这仅是一个无效的收敛，因为上诉的C3命题被违反了，任何交易都不会被确认。从上面的结果中，我们知道在//((n−1)/5//)拜占庭错误的情况下，强正确性总是可以实现的，而且在整个过程中只能达成一个共识。网络只要满足UNL连通性条件，剩下的就是表明，当这两种条件都得到满足时，就会在有限的时间内达成共识。

因为一致性算法本身是确定性的，并且在一致性被终止之前有一个预设的回合数//(t//)，并且当前的一组消息被声明为已批准或不批准。(即使此时没有任何一笔交易超过一致性算法所需的80%阀值，这只是一次无价值的一致性过程)，算法终止的限制因素是节点之间的通信延时。为了弹性化通信延时，节点的响应时间会被监控，延迟大于预设绑定值//(b//)的节点会被从所有UNL中删除。尽管这样做保证了一致性过程会在时间//(tb//)内结束，但是必须指出，在所有因为网络延时而被可能会被丢弃的节点被丢弃之后，最终的UNL必须满足上述正确性和一致性的界限。如果所有节点的初始UNL条件都保持不变，但由于延迟而将一些节点从网络中删除，则正确性和一致性保证不会自动保持。正确性和一致性必须由新的UNL集合进行保持。

##启发式方法和过程
如上所述，在Ripple网络中的所有节点上都实施了启发式延迟限制，以保证一致性算法将收敛。此外，下列启发式方法和过程为RPCA提供了更高的可用性。

1：在每一轮一致性过程中，所有节点都必须有一个强制性的2秒时间来提出它们的初始候选集。虽然这确实为每一轮共识引入了2秒的下限，但可以保证所有具有合理延迟的节点都有能力参与一致性过程。

2：由于选票记录在每一轮一致性过程的账本中，那些进行一些常见的、易于识别的恶意行为节点可以被标记并从网络中删除。包括那些在每个交易上的投票“否”，以及那些持续提议那些无法通过共识的节点。

3：向所有用户提供了一个//(p_c//)值最低的默认UNL。虽然用户可以也应该选择自己的UNL，但是这个默认的节点列表保证即使是毫无经验的用户也可以参与共识过程，这个过程会以极高的概率实现正确性和一致性。

4：使用一种网络分割检测算法，去避免网络中的分叉。虽然共识算法保证了Last-Closed Ledger上的交易是正确的。但它无法阻止在连接性差的网络的不同分区上存在多个最后封闭分类账的可能性。若要尝试并确定是否发生了这样的网络分割，每个节点都会监视其UNL的活动成员的大小。如果该大小突然下降到预设阈值以下，则可能发生网络分割。由于UNL中的某一包含大量节点的分组可能由于各种原因而暂时网络延时陡升，为了避免这种情况被UNL的其他节点判断为高延时节点，而被从UNL中剔除，节点被允许发布一个“临时验证”，在这个阶段，UNL中的节点不对交易进行投票，而是申明共识仍在进行中，而不是在一个已经失去连接的子网络中进行新的一轮的共识。

5：虽然可以仅在一轮共识中应用RPCA。但在要求为80%节点确认的第四轮之前，通过多轮的每一轮都会增加最低所需节点的阀值百分比的共识，可以获取更高的可用性。在少数这样的节点在网络的事务速率中造成瓶颈的情况下，在这些回合可以检测潜在的高延时的节点。在较低阀值要求的回合中，这些延时节点可能能够跟上共识的速度，但是随着阀值的增加，那些跟不上共识速度的节点会被识别出来。就一轮共识而言，很少有交易可以达到80%的节点的确认，从而使得即使是速度较慢的节点也可以跟上共识速度，这会降低整个系统的交易处理速度。